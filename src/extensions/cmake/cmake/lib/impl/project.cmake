include(${CMAKE_CURRENT_LIST_DIR}/../json.cmake)

function(_burt_read_project_json path)
    # The binary directory corresponding to this current directory should have a burt.json file in that
    # directory that fully defines the JSON with all default values and pre-processing. This allows the CMake
    # code here to assume the file is fully defined and allows us to take shortcuts on a lot of things.
    get_directory_property(_binary_dir DIRECTORY "${CMAKE_SOURCE_DIR}/${rel_path}" BINARY_DIR)
    set(_json_path "${_binary_dir}/burt.json" "")
    if(NOT EXISTS ${_json_path})
        if(EXISTS "${CMAKE_SOURCE_DIR}/${rel_path}/burt.json")
            # In this case, we probably didn't run a 'burt init' on the repo, so run that now.
            burt_cli_execute(COMMAND init --force COMMAND_ERROR_IS_FATAL ANY)
        else()
            message(FATAL_ERROR "Cannot load burt.json from ${CMAKE_CURRENT_LIST_DIR}")
        endif()
    endif()
    file(READ ${_json_path} _json)
    set(${out_var} ${_json} PARENT_SCOPE)
endfunction()

function(_burt_project_find_package_json_files base_path json pkg_out_var)
    burt_json_query(_num_modules ${json} LENGTH "modules")
    set(_pkg_files_found "")
    if(NOT _num_modules STREQUAL "NOTFOUND")
        math(EXPR _modules_end "${_num_modules}-1")
        foreach(_module_idx RANGE ${_modules_end})
            burt_json_query(_module_type ${json} TYPE "modules" ${_module_idx})
            if(_module_type STREQUAL "STRING")
                burt_json_query(_module_path ${json} GET "modules" ${_module_idx})
                set(_module_abs_path ${_module_path})
                cmake_path(ABSOLUTE_PATH _module_abs_path BASE_DIRECTORY ${base_path} NORMALIZE)
                set(_module_file_path "${_module_abs_path}/burt.json")
                if(NOT EXISTS ${_module_abs_path})
                    message("module_abs_path: ${_module_abs_path}")
                    message(FATAL_ERROR "Package defined in '${base_path}/burt.json' specifies a module path "
                        "that does not exist: '${_module_path}'")
                elseif(NOT IS_DIRECTORY ${_module_abs_path})
                    message(FATAL_ERROR "Package defined in '${base_path}/burt.json' specifies a module path "
                        "that is not a directory: '${_module_path}'")
                elseif(NOT EXISTS ${_module_file_path})
                    message(FATAL_ERROR "Package defined in '${base_path}/burt.json' specifies a module path "
                        "that does not contain a 'burt.json' file: '${_module_path}'")
                endif()
                list(APPEND _pkg_files_found ${_module_file_path})
            endif()
        endforeach()
    endif()
    set(${pkg_out_var} ${_pkg_files_found} PARENT_SCOPE)
endfunction()

function(_burt_project_find_source_json_files out_var path)
    # Assume the path we were given contains a 'burt.json'. If it does not, this should be an error condition.
    set(_this_file "${path}/burt.json")
    if(NOT EXISTS "${_this_file}")
        message(FATAL_ERROR "Could not load referenced 'burt.json' file at '${path}'")
    endif()
    set(_found_files ${_this_file})

    # Load in the burt.json file and parse the paths out of it.
    file(READ ${_this_file} _this_json)

    # Each entry in 'subprojects' is a path to pass to this recursively.
    burt_json_query(_num_subprojects ${_this_json} LENGTH "subProjects")
    if(NOT _num_subprojects STREQUAL "NOTFOUND")
        math(EXPR _subprojects_end "${_num_subprojects}-1")
        foreach(_subproject_idx RANGE ${_subprojects_end})
            burt_json_query(_subproject ${_this_json} GET "subProjects" ${_subproject_idx})
            cmake_path(ABSOLUTE_PATH _subproject BASE_DIRECTORY ${path} NORMALIZE)
            _burt_project_find_source_json_files(_subproject_files ${_subproject})
            if(NOT _subproject_files STREQUAL "")
                list(APPEND _found_files ${_subproject_files})
            endif()
        endforeach()
    endif()

    # Each entry in the 'packages' is either a package object or a path to be recursed.
    burt_json_query(_num_packages ${_this_json} LENGTH "packages")
    if(NOT _num_packages STREQUAL "NOTFOUND")
        math(EXPR _packages_end "${_num_packages}-1")
        foreach(_package_idx RANGE ${_packages_end})
            burt_json_query(_pkg_entry_type ${_this_json} TYPE "packages" ${_package_idx})
            set(_package_abs_path ${path})
            if(_pkg_entry_type STREQUAL "OBJECT")
                burt_json_query(_package_json ${_this_json} GET "packages" ${_package_idx})
            elseif(_pkg_entry_type STREQUAL "STRING")
                burt_json_query(_package_path ${_this_json} GET "packages" ${_package_idx})
                set(_package_abs_path ${_package_path})
                cmake_path(ABSOLUTE_PATH _package_abs_path BASE_DIRECTORY ${path} NORMALIZE)
                set(_package_file_path "${_package_abs_path}/burt.json")
                if(NOT EXISTS ${_package_abs_path})
                    message(FATAL_ERROR "Project JSON at '${_this_file}' contains a package path that does "
                        "not exist: '${_package_path}'")
                elseif(NOT IS_DIRECTORY ${_package_abs_path})
                    message(FATAL_ERROR "Project JSON at '${_this_file}' contains a package path that is not "
                        "a directory: '${_package_path}")
                elseif(NOT EXISTS ${_package_file_path})
                    message(FATAL_ERROR "Project JSON at '${_this_file}' contains a package path that does "
                        "not contain a 'burt.json' file: '${_package_path}'")
                endif()
                list(APPEND _found_files ${_package_file_path})
                file(READ ${_package_file_path} _package_json)
                set(_project_path "${}")
            else()
                message(FATAL_ERROR "Invalid package entry type in project JSON file. Expected 'OBJECT' or "
                    "'STRING', found '${_pkg_entry_type}' instead")
            endif()
            _burt_project_find_package_json_files(${_package_abs_path} ${_package_json} _package_json_files)
            if(_package_json_files)
                list(APPEND _found_files ${_package_json_files})
            endif()
        endforeach()
    endif()
    set(${out_var} ${_found_files} PARENT_SCOPE)
endfunction()
